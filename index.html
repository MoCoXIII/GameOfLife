<!DOCTYPE html>
<html>

<head>
    <title>PVP Colorful Game of Life</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        .container {
            display: flex;
            gap: 20px;
            padding: 20px;
            height: 100%;
            box-sizing: border-box;
        }

        #grid {
            display: grid;
            gap: 0px;
            background: #333;
            padding: 1px;
            width: 80vh;
            /* Default to 80% of viewport height */
            height: 80vh;
            max-width: 80vw;
            /* Limit to 80% of viewport width */
            max-height: 80vw;
        }

        .cell {
            background: white;
            border: 1px solid #ddd;
            cursor: pointer;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
        }

        .color-picker {
            width: 50px;
            height: 50px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .color-count-item {
            padding: 4px;
            margin: 2px 0;
            border-radius: 3px;
            display: block;
            /* Stack vertically */
            width: 100%;
            /* Take full width */
            box-sizing: border-box;
            /* Include padding in width */
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label>Draw Color:</label>
                <input type="color" class="color-picker" value="#ff0000">
            </div>
            <div class="control-group">
                <label>Rows:</label>
                <input type="number" id="rows" value="20">
            </div>
            <div class="control-group">
                <label>Columns:</label>
                <input type="number" id="cols" value="20">
            </div>
            <div class="control-group">
                <label>Color Limit:</label>
                <input type="number" id="colorLimit" value="20">
            </div>
            <div class="control-group">
                <label>Step Delay (ms):</label>
                <input type="number" id="stepDelay" value="1000">
            </div>
            <button onclick="initGrid()">Reset Grid</button>
            <button onclick="startStop()">Start</button>
            <button onclick="updateColorCounts()">Count Current Cells</button>
            <div id="colorCounts"></div>
        </div>
        <div id="grid"></div>
    </div>

    <script>
        let grid = [];
        let running = false;
        let colorCounts = {};
        let selectedColor = '#ff0000';
        let colorLimit = 50;
        let stepDelay = 100;

        document.querySelector('.color-picker').addEventListener('input', function (e) {
            selectedColor = e.target.value;
        });

        function initGrid() {
            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            colorLimit = parseInt(document.getElementById('colorLimit').value);
            stepDelay = parseInt(document.getElementById('stepDelay').value);
            colorCounts = {};

            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';

            grid = Array(rows).fill().map(() =>
                Array(cols).fill().map(() => ({
                    alive: false,
                    color: null
                }))
            );

            // Calculate cell size based on grid dimensions
            const gridSize = Math.min(window.innerHeight * 0.8, window.innerWidth * 0.8);
            const cellSize = gridSize / Math.max(rows, cols);
            gridElement.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            gridElement.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.addEventListener('click', () => placeCell(i, j));
                    gridElement.appendChild(cell);
                }
            }
        }

        function placeCell(i, j) {
            if (!running && (colorCounts[selectedColor] || 0) < colorLimit) {
                if (selectedColor === '#ffffff') { // Treat white as "no color"
                    grid[i][j].alive = false;
                    grid[i][j].color = null;
                } else {
                    grid[i][j].alive = true;
                    grid[i][j].color = selectedColor;
                    colorCounts[selectedColor] = (colorCounts[selectedColor] || 0) + 1;
                }
                updateDisplay();
            }
        }

        function updateDisplay() {
            const cells = document.getElementsByClassName('cell');
            let idx = 0;
            for (let row of grid) {
                for (let cell of row) {
                    cells[idx].style.background = cell.alive ? cell.color : 'white';
                    idx++;
                }
            }
            updateColorCounts();
        }

        function getTextColor(bgColor) {
            const hex = bgColor.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.5 ? 'black' : 'white';
        }

        function updateColorCounts() {
            const counts = {};
            grid.forEach(row => row.forEach(cell => {
                if (cell.alive && cell.color) {
                    counts[cell.color] = (counts[cell.color] || 0) + 1;
                }
            }));

            let countsHTML = "Cell Counts:<br>";
            for (let color in counts) {
                const textColor = getTextColor(color);
                countsHTML += `
                    <div class="color-count-item" style="background:${color};color:${textColor}">
                        ${color}: ${counts[color]}
                    </div>
                `;
            }
            document.getElementById('colorCounts').innerHTML = countsHTML;
        }

        function getNextGeneration() {
            const newGrid = grid.map(row => row.map(cell => ({ ...cell })));

            for (let i = 0; i < grid.length; i++) {
                for (let j = 0; j < grid[i].length; j++) {
                    const neighbors = getNeighbors(i, j);
                    const liveNeighbors = neighbors.filter(n => n.alive).length;

                    if (grid[i][j].alive) {
                        newGrid[i][j].alive = liveNeighbors === 2 || liveNeighbors === 3;
                    } else {
                        if (liveNeighbors === 3) {
                            newGrid[i][j].alive = true;
                            newGrid[i][j].color = calculateNewColor(neighbors);
                        }
                    }
                }
            }
            return newGrid;
        }

        function getNeighbors(i, j) {
            const neighbors = [];
            const rows = grid.length;
            const cols = grid[0].length;

            for (let di = -1; di <= 1; di++) {
                for (let dj = -1; dj <= 1; dj++) {
                    if (di === 0 && dj === 0) continue;
                    const ni = (i + di + rows) % rows; // Wrap around rows
                    const nj = (j + dj + cols) % cols; // Wrap around columns
                    neighbors.push(grid[ni][nj]);
                }
            }
            return neighbors;
        }

        function calculateNewColor(neighbors) {
            const colorFreq = {};
            const aliveNeighbors = neighbors.filter(n => n.alive && n.color !== '#ffffff'); // Ignore white

            if (aliveNeighbors.length === 0) return '#ffffff'; // Default to white if no valid neighbors

            aliveNeighbors.forEach(n => {
                colorFreq[n.color] = (colorFreq[n.color] || 0) + 1;
            });

            const maxCount = Math.max(...Object.values(colorFreq));
            const topColors = Object.keys(colorFreq).filter(c => colorFreq[c] === maxCount);

            if (topColors.length === 1) return topColors[0];

            // Average colors
            let r = 0, g = 0, b = 0;
            topColors.forEach(color => {
                const hex = color.replace('#', '');
                r += parseInt(hex.substring(0, 2), 16);
                g += parseInt(hex.substring(2, 4), 16);
                b += parseInt(hex.substring(4, 6), 16);
            });

            r = Math.round(r / topColors.length).toString(16).padStart(2, '0');
            g = Math.round(g / topColors.length).toString(16).padStart(2, '0');
            b = Math.round(b / topColors.length).toString(16).padStart(2, '0');

            return `#${r}${g}${b}`;
        }

        function gameLoop() {
            if (running) {
                grid = getNextGeneration();
                updateDisplay();
                setTimeout(() => gameLoop(), stepDelay);
            }
        }

        function startStop() {
            running = !running;
            document.querySelector('button[onclick="startStop()"]').innerText = running ? 'Stop' : 'Start';
            stepDelay = parseInt(document.getElementById('stepDelay').value);
            if (running) gameLoop();
        }

        window.addEventListener('resize', initGrid);

        initGrid();
    </script>
</body>

</html>